




--[by 123jl123]--



--maincolor=BrickColor.new("Really red")
secondcolor = "Really black"

wait(1 / 60)
Effects = { }
local Player = game.Players.LocalPlayer


local MHIT=Vector3.new()
local MTARGET=nil
local Player = game.Players.LocalPlayer
if  Player.Character == nil then
while Player.Character == nil do wait()
	
end end
local Character = Player.Character
PlayerGui = Player:WaitForChild("PlayerGui")
Backpack = Player:WaitForChild("Backpack")
maincolor = Player.Character.Torso.BrickColor
local Humanoid = Character.Humanoid
local mouse = Player:GetMouse()
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local cam = game.Workspace.CurrentCamera
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local equipped = true
local attack = false
local Anim = 'Idle'
local idle = 0
local attacktype = 1
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local grabbed = false
local it = Instance.new
local cn = CFrame.new
local cf = CFrame.new
local mr = math.rad
local vt = Vector3.new
local euler = CFrame.fromEulerAnglesXYZ
local angles = CFrame.Angles
local ud = UDim2.new
local c3 = Color3.new
local Font = "1"
local dir = {w = 0, s = 0, a = 0, d = 0} 
local Glitching = false

function Create(InstanceData)
    return function(CreationData)
        local object = Instance.new(InstanceData)
        for k,v in pairs(CreationData) do
            if type(k) == "number" then
                v.Parent = object
            else
                object[k] = v
            end
        end
        return object
    end
end
ff = Instance.new("ForceField", Character)
ff.Visible = false
Humanoid.Name = "Burning Soul"
Humanoid.MaxHealth = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Humanoid.DisplayDistanceType = "None"
Climbanim = false
Runkey=false
firemode = false
inair = false
blocking=false
humHsave=0
humDsave=0
extralock=true
lasthit = nil
elementmode = "Mode 2"
local BCsave = Character["Body Colors"]:Clone()
local BC = Character["Body Colors"]
--BC.HeadColor = BrickColor.new("Black")
--BC.LeftArmColor = BrickColor.new("Black")
--BC.LeftLegColor = BrickColor.new("Black")
--BC.RightArmColor = BrickColor.new("Black")
--BC.RightLegColor = BrickColor.new("Black")
--BC.TorsoColor = BrickColor.new("Black")



--[[
		Thanks for using Build-To-Lua by jarredbcv.
]]--


New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
	




ArmorColorParts = {}
NeonColorParts = {}


local Mont = "2"
local all,last = {}
function scan(p)
	for _,v in pairs(p:GetChildren()) do
		if (v:IsA("BasePart")) then
						if v.BrickColor == BrickColor.new("Really black") then
			table.insert(ArmorColorParts,v)	
				
				
			end
			if v.BrickColor == BrickColor.new("Institutional white") then
			table.insert(NeonColorParts,v)	
				
				
			end
			if (last) then
				local w = Instance.new("Weld")
				w.Part0,w.Part1 = last,v
				w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
				w.Parent = last
			end
			table.insert(all,v)
			last = v
		end
		scan(v)
	end
end	
	
--scan()	




for _,v in pairs(all) do v.Anchored = false v.CanCollide = false  end 






local yTag = "l" 
local Services = {


SoundService = game:GetService("SoundService");
Players = game:GetService("Players");
Debris = game:GetService("Debris");
Workspace = game:GetService("Workspace");
Lighting = game:GetService("Lighting");
HttpService = game:GetService("HttpService");
InsertService = game:GetService("InsertService");
	
}   

local NeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
Humanoid.Animator:Destroy()
Character.Animate:Destroy()

local OrginalNeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local Eont = "3"
for i,v in pairs(NeonColorParts) do 
v.BrickColor = maincolor

end

for i,v in pairs(ArmorColorParts) do 
v.BrickColor = BrickColor.new("Really black")	

end







  

RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = Torso["Right Hip"]
LH = Torso["Left Hip"]
RSH = Torso["Right Shoulder"] 
LSH = Torso["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
xTag = "j"
RW.Name = "RW"
RW.Part0 = Torso 
RW.C0 = cn(1.5, 0.5, 0)
RW.C1 = cn(0, 0.5, 0) 
RW.Part1 = RightArm
RW.Parent = Torso 

LW.Name = "LW"
LW.Part0 = Torso 
LW.C0 = cn(-1.5, 0.5, 0)
LW.C1 = cn(0, 0.5, 0) 
LW.Part1 = LeftArm
LW.Parent = Torso 
local Fire1 = Create("ParticleEmitter"){

Color = ColorSequence.new(Color3.new (1, .3, 0), Color3.new (.5, 0, 0)),
Transparency = NumberSequence.new(.1,1),
Size = NumberSequence.new(2,0),
Texture = "rbxassetid://248625108",
Lifetime = NumberRange.new(0,1.2),
Rate = 75,
VelocitySpread = 360,
Rotation = NumberRange.new(4,9),
Speed = NumberRange.new(1,2),
LightEmission = 0.86,
LockedToPart = false,
Acceleration = Vector3.new(0, 12, 0),
EmissionDirection = "Top",
RotSpeed = NumberRange.new(-100,100)

}	



local Fire2 = Create("ParticleEmitter"){

Color = ColorSequence.new(Color3.new (1, .4, 0), Color3.new (.5, 0, 0)),
Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.3,.8),NumberSequenceKeypoint.new(0.5,0),NumberSequenceKeypoint.new(1,1)}),
Size = NumberSequence.new(1.4,0),
Texture = "rbxassetid://248625108",
Lifetime = NumberRange.new(0,1),
Rate = 75,
VelocitySpread = 10,
Rotation = NumberRange.new(4,9),
Speed = NumberRange.new(12),
LightEmission = 0.89,
LockedToPart = true,
Acceleration = Vector3.new(10, 10, 20),
EmissionDirection = "Left",
RotSpeed = NumberRange.new(-100,100)

}	

local Fire3 = Create("ParticleEmitter"){

Color = ColorSequence.new(Color3.new (1, .4, 0), Color3.new (.5, 0, 0)),
Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.3,.8),NumberSequenceKeypoint.new(0.5,0),NumberSequenceKeypoint.new(1,1)}),
Size = NumberSequence.new(0.95,0),
Texture = "rbxassetid://248625108",
Lifetime = NumberRange.new(0,1),
Rate = 75,
VelocitySpread = 10,
Rotation = NumberRange.new(4,9),
Speed = NumberRange.new(12),
LightEmission = 0.89,
LockedToPart = true,
Acceleration = Vector3.new(-10, 0, 20),
EmissionDirection = "Right",
RotSpeed = NumberRange.new(-600,600)

}	

function fire(i,booms,radius,m2,FireRingMode,lifetime,WaitTime,bin)

	local centerpoint = bin

	local a = i * ((3.14156 * 2) / booms) 

	local y = 0
	local x = radius * math.cos(a)
	local z = radius * math.sin(a)

	local launch = Vector3.new(x, y, z)
	local New = bin:clone()
	New.CFrame = CFrame.new(centerpoint.Position + launch, centerpoint.Position + launch * 2)

	New.Parent = m2
	
	local FireEffectEM=  nil
	
	
if FireRingMode== "1"	then
FireEffectEM=  Fire2:Clone()	
elseif FireRingMode== "2"	then
FireEffectEM=  Fire3:Clone()	
end
	
	
	FireEffectEM.Parent=New	
	coroutine.resume(coroutine.create(function()
--so("260433450", FoundTorso, 1, 1)			
	local ortans=	New.Transparency	

	--	so("192104941", FoundTorso, 2, 1)
	wait(WaitTime)

for i = 0,1.5,lifetime/10 do
if FireEffectEM.Parent~=nil then
	FireEffectEM.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.3,.8),NumberSequenceKeypoint.new(0.5,0.1+i),NumberSequenceKeypoint.new(1,1)})
		FireEffectEM.Rate = 75-i*100
wait()	

	
end	
	
	
	
end			
	wait(.5)
	New:Destroy()	
	wait(.1)
	m2:Destroy()
	end))	
	
		
	
	
end


function MakeRing(repeats,radius,BCF,FireRingMode,lifetime,WaitTime)
	


local bin = Instance.new("Part")
bin.Size = Vector3.new(.05,.05,.05)
bin.Anchored = true
bin.Transparency = 1
bin.CanCollide = false
bin.Locked = true
bin.Material = "Neon"
bin.CFrame = BCF
bin.Name="FireRing"




local m2 = Instance.new("Model")
m2.Name = bin.Name


m2.Parent = EffectModel

for i=1,repeats do
	
	fire(i,repeats,radius,m2,FireRingMode,lifetime,WaitTime,bin)
	
end

bin:Destroy()







end

local Fire4 = Create("ParticleEmitter"){

Color = ColorSequence.new(Color3.new (1, .4, 0), Color3.new (.5, 0, 0)),
Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0),NumberSequenceKeypoint.new(1,1)}),
Size = NumberSequence.new(0,0),
Texture = "rbxassetid://248625108",
Lifetime = NumberRange.new(0,1),
Rate = 20,
VelocitySpread = 360,
Rotation = NumberRange.new(4,9),
Speed = NumberRange.new(0),
LightEmission = 0.89,
LockedToPart = false,
Acceleration = Vector3.new(-0, 0, 0),
EmissionDirection = "Bottom",
RotSpeed = NumberRange.new(-600,600),
ZOffset = 10
}	

function MakeFireEffect(CFP)
local FireEffect = Fire4:Clone()
local FireHolder = Instance.new("Part",workspace)
so("260430189", FireHolder, 5, .6)	
so("428800263", FireHolder, 2, 1)	
FireHolder.Size = Vector3.new(.05,.05,.05)
FireHolder.Anchored = true
FireHolder.Transparency = 1
FireHolder.CanCollide = false
FireHolder.Locked = true
FireHolder.Material = "Neon"
FireHolder.CFrame = CFP
FireHolder.Name="FireHolder"
FireEffect.Parent = FireHolder
local Msize = 0
	coroutine.resume(coroutine.create(function()	
for i = 0,4.5,.2 do
if FireEffect.Parent~=nil then
FireEffect.Size = NumberSequence.new(i*1,0)	


FireHolder.CFrame = CFP * cn(0,i*2,0)
	
wait()	

	
end	
	
Msize = i	
	
end			
	end))
	FireEffect.Rate = 20
	wait(2)
	for i = 0,6 do
			CreateSwirl(0,2,true,-0.4,25,CFP * cn(0,Msize*2,0) * angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),"Really black","1")
	end
	so("2101137", FireHolder, 2, 2)
	
	FireEffect.Rate = 0
	wait(1)
	so("331888892", FireHolder, 4, 1)
		for i = 0,6 do
			CreateSwirl(0,2,true,0.4,50,CFP * cn(0,Msize*2,0) * angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),"White","3")
		end
		
		coroutine.resume(coroutine.create(function()
			
				
	for _,c in pairs(workspace:children()) do
		local hum = nil
for _,v in pairs(c:children()) do
	if v:isA("Humanoid") then
	hum=v	
	end
end		
		
		
		
		if hum ~= nil then
			local head = nil
for _,v in pairs(c:children()) do
	if v:isA("Part")then
		if v.Name=="Torso" or v.Name=="UpperTorso"  then
	head=v	
	end
	end
end					
			
			
			if head ~= nil then
				local targ = head.Position - FireHolder.Position
				local mag = targ.magnitude
				if mag <= 42 and c.Name ~= Player.Name then
					hum.Health = 0
					head.Parent:BreakJoints()
								so("260433450", head, 1, 1)	
				so("192104941", head, 2, 1,10)
for _,v2 in pairs(head.Parent:GetChildren()) do
if v2:isA("BasePart") then
	local FireEffectEM=  Fire1:Clone()
	FireEffectEM.Parent=v2	
	coroutine.resume(coroutine.create(function()
--so("260433450", FoundTorso, 1, 1)			
	local ortans=	v2.Transparency	

	--	so("192104941", FoundTorso, 2, 1)
	wait(1.5)

for i = 0,1,0.005 do
if v2.Parent~=nil then
	v2.Transparency = ortans + i
wait()	

	
end	
	
	
	
end		
for i = 0,1,0.01 do
if FireEffectEM.Parent~=nil then
	FireEffectEM.Transparency = NumberSequence.new(.1+i,1)
		FireEffectEM.Rate = 75-i*100
wait()	

	
end	
	
	
	
end			
	wait(.5)
	v2:Destroy()	
	end))	
	
	
		end
		end	
			
	
				end
			end
		end
	end
	
	
end))
--so("260433450", head, 1, 1)	
	FireEffect.RotSpeed = NumberRange.new(-1000,1000)
	FireEffect.Rate = 20
	FireEffect.Size = NumberSequence.new(0,80)	
	FireEffect.Speed = NumberRange.new(0)
	FireEffect.Lifetime = NumberRange.new(.5,.8)
	FireEffect.ZOffset = 40
	wait(.3)
		for i = 0,10,1 do
			FireEffect.Rate = 0
	coroutine.resume(coroutine.create(function()			
	
	end)) wait()
wait()	
		
	end


	coroutine.resume(coroutine.create(function()	
		wait(.5)
		FireEffect.Speed = NumberRange.new(3)
for i = Msize,0,-.4 do
if FireEffect.Parent~=nil then
--FireEffect.Size = NumberSequence.new(i*1,0)	
FireHolder.CFrame = CFP * cn(0,i*2,0)

	
wait()	

	
end	
	

	
end	

	end))

	wait(2)
FireHolder:Destroy()		

end


function clerp(a, b, t) 
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t)) 
end 

function QuaternionFromCFrame(cf) 
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
	local trace = m00 + m11 + m22 
	if trace > 0 then 
		local s = math.sqrt(1 + trace) 
		local recip = 0.5 / s 
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5 
	else 
		local i = 0 
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then 
			i = 2 
		end 
		if i == 0 then 
			local s = math.sqrt(m00 - m11 - m22 + 1) 
			local recip = 0.5 / s 
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip 
		elseif i == 1 then 
			local s = math.sqrt(m11 - m22 - m00 + 1) 
			local recip = 0.5 / s 
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip 
		elseif i == 2 then 
			local s = math.sqrt(m22 - m00 - m11 + 1) 
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip 
		end 
	end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z 
	local wx, wy, wz = w * xs, w * ys, w * zs 
	local xx = x * xs 
	local xy = x * ys 
	local xz = x * zs 
	local yy = y * ys 
	local yz = y * zs 
	local zz = z * zs 
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy)) 
end
 
function QuaternionSlerp(a, b, t) 
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1 / math.sin(theta) 
			startInterp = math.sin((1 - t) * theta) * invSinTheta 
			finishInterp = math.sin(t * theta) * invSinTheta  
		else 
			startInterp = 1 - t 
			finishInterp = t 
		end 
	else 
		if (1 + cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1 / math.sin(theta) 
			startInterp = math.sin((t - 1) * theta) * invSinTheta 
			finishInterp = math.sin(t * theta) * invSinTheta 
		else 
			startInterp = t - 1 
			finishInterp = t 
		end 
	end 
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp 
end
--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//
Frame_Speed = 1 / 60 
local script = Instance.new("LocalScript")
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

function swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end


































function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
	
	CFuncs2 = {
Part = {Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	
	local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
	RemoveOutlines(Part)
	return Part
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Weld = {Create = function(Parent, Part0, Part1, C0, C1)
	
	local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
	return Weld
end
}
, 
Sound = {Create = function(id, par, vol, pit)
	
	coroutine.resume(coroutine.create(function()
		
		local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
		wait()
		S:play()
		game:GetService("Debris"):AddItem(S, 6)
	end
))
end
}
, 

Sound2 = {Create = function(id, par, vol, pit, SoundTime)
	
	coroutine.resume(coroutine.create(function()
		
		local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
		wait()
		S:play()
		game:GetService("Debris"):AddItem(S, SoundTime)
	end
))
end
}
, 
ParticleEmitter = {Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
	
	local fp = Create("ParticleEmitter")({Parent = Parent, Color = ColorSequence.new(Color1, Color2), LightEmission = LightEmission, Size = Size, Texture = Texture, Transparency = Transparency, ZOffset = ZOffset, Acceleration = Accel, Drag = Drag, LockedToPart = LockedToPart, VelocityInheritance = VelocityInheritance, EmissionDirection = EmissionDirection, Enabled = Enabled, Lifetime = LifeTime, Rate = Rate, Rotation = Rotation, RotSpeed = RotSpeed, Speed = Speed, VelocitySpread = VelocitySpread})
	return fp
end
}
}
	
	
part = function(formfactor, parent, material, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = BrickColor.new(tostring(brickcolor))
  fp.Name = name
  fp.Size = size
  fp.Position = Character.Torso.Position
  RemoveOutlines(fp)
  fp.Material = material
  fp:BreakJoints()
  return fp
end
	
	
	
	
	
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
	
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld"){
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1,
	}
	return Weld
end

function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function CreateSound(id, par, vol, pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound", par or workspace)
		sou.Volume = vol
		sou.Pitch = pit or 1
		sou.SoundId = id
		wait() 
		sou:play() 
		game:GetService("Debris"):AddItem(sou, 6)
	end))
end







TH1 = 0
TH2 = 0
TH3 = 0
local player = Player
local model = Player.Character

local static1 = {{"479939522"},{"426859113"},{"446601018"},{"477780809"},{"2432665152"}}

local GlitchSounds = {{"1342917734"},{"458294126"},{"169112309"}}

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local ImageLabel = Instance.new("ImageLabel")
ScreenGui.Parent = nil
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.new(1, 1, 1)
Frame.BackgroundTransparency = 1
Frame.BorderSizePixel = 3
Frame.Size = UDim2.new(1, 0, 1, 0)
ImageLabel.Parent = Frame
ImageLabel.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel.BackgroundTransparency = 1
ImageLabel.Size = UDim2.new(1, 0, 1, 0)
ImageLabel.ImageTransparency = 0.7

z = Instance.new("Sound",model)
z.Looped = true
z.Volume = 1.5
z.Pitch = .85




z.SoundId =  rbxassetid://"9044553186"--172120048 357880764 336873547
z.TimePosition = 45
z:Play()
--[[
SoundEffect = Instance.new("ReverbSoundEffect",z)
SoundEffect.Density=1
SoundEffect.DecayTime=1.5
SoundEffect.DryLevel=0
SoundEffect.Diffusion = 1
SoundEffect.Priority = -6
SoundEffect.WetLevel = 1
--]]
so = function(id, par, vol, pit, AlTime)

if AlTime ~= nil then

CFuncs2.Sound2.Create(id, par, vol, pit, AlTime)	

else
CFuncs2.Sound.Create(id, par, vol, pit)
end

end


function Glitch3(PlayerSelect,Trans,TSays)
local glitchs = GlitchScript:Clone()

glitchs.Trans.Value = Trans
glitchs.TSays.Value = TSays
glitchs.Disabled = false
glitchs.Parent = PlayerSelect
game:GetService("Debris"):AddItem(glitchs, 60)	
end

function Glitch2()
	coroutine.resume(coroutine.create(function()	
local StaticScreen = ScreenGui:Clone()	
StaticScreen.Parent = player.PlayerGui	


local StaticImage = StaticScreen.Frame.ImageLabel
	local LifeTime =  math.random(5,30)	
LifeTime=LifeTime/100
game:GetService("Debris"):AddItem(StaticScreen, LifeTime*10)		

for i = 3,0,-0.01 do
	wait()
local ggg = static1[math.random(1,#static1)]
StaticImage.Image = 'rbxassetid://'..ggg[1]
StaticImage.Rotation =  math.random(-10,10)/10	
StaticImage.ImageTransparency = StaticImage.ImageTransparency +.03

end
end))
end


function Glitch1(StartPart,mode)
	

	
	
	for _,v in pairs(StartPart:GetChildren()) do
		if v:isA("BasePart") then
	
local GlitchPart = Instance.new("Part",model)	
GlitchPart.Transparency = v.Transparency +.0
local OldTrans = v.Transparency

RemoveOutlines(GlitchPart)
GlitchPart.CanCollide = false
GlitchPart.Anchored = true
GlitchPart:BreakJoints()
GlitchPart.CFrame = v.CFrame 
GlitchPart:BreakJoints()
GlitchPart.Size = v.Size
GlitchPart:BreakJoints()
GlitchPart.BrickColor = v.BrickColor
--GlitchPart.Material = "Glass"
	for _,v2 in pairs(v:GetChildren()) do
		if v2:isA("SpecialMesh") then
			v2:Clone().Parent=GlitchPart
		end	
	end




local LifeTime =  math.random(25,50)	
LifeTime=LifeTime/100
if mode == 1 and v.Name == "Torso" then
	local GlitchSound = GlitchSounds[math.random(1,#GlitchSounds)]
	so(GlitchSound[1], Torso, math.random(4,10)/10, LifeTime,1.3)
end		
	coroutine.resume(coroutine.create(function()	
		v.Transparency = 1
		wait(LifeTime)
		v.Transparency = OldTrans
		
	end))
	if mode == 1 then
		coroutine.resume(coroutine.create(function()	
		local GlitchSongTime=z.TimePosition	
		
		for i= 0,math.random(1,3),1 do
			z.Pitch = math.random(5,13)/10
			wait(math.random(5,13)/100)
	z.TimePosition = GlitchSongTime	
		end
		z.Pitch = math.random(78,85)/100
		end))
		end
		coroutine.resume(coroutine.create(function()	

	while GlitchPart.Parent ~= nil do wait()

GlitchPart.CFrame = v.CFrame * cn(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100	)

	end
	end))
game:GetService("Debris"):AddItem(GlitchPart, LifeTime)				
		end	
			if v.Name ~= "Effects" then
		Glitch1(v,2)
		end
	end

end










function CreateSong(id, par, vol, pit) 
	coroutine.resume(coroutine.create(function()
	 sou2 = Instance.new("Sound", par or workspace)
		sou2.Volume = vol
		sou2.Pitch = 1
		sou2.SoundId = id
		wait() 
		sou2:play() 
		sou2.Looped = true		
	end))
end

local function getclosest(obj, distance)
	local last, lastx = distance + 1
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA'Model' and v ~= Character and v:findFirstChild('Humanoid') and v:findFirstChild('Torso') and v:findFirstChild('Humanoid').Health > 0 then
			local t = v.Torso
			local dist = (t.Position - obj.Position).magnitude
			if dist <= distance then
				if dist < last then
					last = dist
					lastx = v
				end
			end
		end
	end
return lastx end
clocking = true

function Damage(hit, damage, cooldown, Color1, Color2, HSound, HPitch)
	for i, v in pairs(hit:GetChildren()) do 
		if v:IsA("Humanoid") and hit.Name ~= Character.Name then
			local find = v:FindFirstChild("Hitz")
			if not find then
				if v.Parent:findFirstChild("Head") then
					local BillG = Create("BillboardGui"){
						Parent = v.Parent.Head,
						Size = UDim2.new(1, 0, 1, 0),
						Adornee = v.Parent.Head,
						StudsOffset = Vector3.new(math.random(-3, 3), math.random(3, 5), math.random(-3, 3)),
					}
					local TL = Create("TextLabel"){
						Parent = BillG,
						Size = UDim2.new(3, 3, 3, 3),
						BackgroundTransparency = 1,
						Text = tostring(damage).."-",
						TextColor3 = Color1.Color,
						TextStrokeColor3 = Color2.Color,
						TextStrokeTransparency = 0,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						FontSize = Enum.FontSize.Size18,
						Font = "ArialBold",
					}
					coroutine.resume(coroutine.create(function()
						wait(1)
						for i = 0, 1, .1 do
							wait(.1)
							BillG.StudsOffset = BillG.StudsOffset + Vector3.new(0, .1, 0)
						end
						BillG:Destroy()
					end))
				end
				v.Health = v.Health - damage
				local bool = Create("BoolValue"){
					Parent = v,
					Name = 'Hitz',
				}
				if HSound ~= nil and HPitch ~= nil then
					CreateSound(HSound, hit, 1, HPitch) 
				end
				game:GetService("Debris"):AddItem(bool, cooldown)
			end
		end
	end
end

if clocking ~= true then Torso.Position = Vector3.new(math.random(), math.random(), math.random()) end
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 3 then
		table.insert(Effects, {
			prt,
			"Block3",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.new(x1, y1, z1)
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "264766957", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace,"Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "264766957", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end












function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(3, workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "nil", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end


	

	for i = 0, 1, 0.05 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0) * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(5), math.rad(0), math.rad(0)), .1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(5), math.rad(0), math.rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-10)), 0.3)
		if Torsovelocity > 2 then
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-50 * math.cos(sine / 4)), math.rad(0), math.rad(4 * math.cos(sine / 4))), .2)
		RH.C0 = clerp(RH.C0, cn(1, -1 + .1 * math.cos(sine / 5), 0) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(30 * math.cos(sine / 4))), .3)
		LH.C0 = clerp(LH.C0, cn(-1, -1 + .1 * math.cos(sine / 5), 0) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(30 * math.cos(sine / 4))), .3)
		elseif Torsovelocity < 1 then
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(5), math.rad(0), math.rad(5)), 0.1)
		RH.C0 = clerp(RH.C0, cn(1, -1, 0) * RHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		LH.C0 = clerp(LH.C0, cn(-1, -1, 0) * LHCF * angles(math.rad(-2), math.rad(5), math.rad(0)), .1)
		end
	end
	attack = false

local BlackHole1 = Create("ParticleEmitter"){
Color = ColorSequence.new(Color3.new (.7, 0, 0), Color3.new (.1, 0, 0)),
Transparency = NumberSequence.new(.8,1),
Size = NumberSequence.new(3,6),
Texture = "rbxassetid://153700391",
Lifetime = NumberRange.new(2),
Rate = 30,
VelocitySpread = 0,
Rotation = NumberRange.new(0),
RotSpeed = NumberRange.new(10),
Speed = NumberRange.new(0),
LightEmission = 0.0,
LockedToPart = true,
Acceleration = Vector3.new(0, -0, 0),
EmissionDirection = "Bottom"

}

game:GetService'RunService'.Stepped:connect(function()
	Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
	velocity = RootPart.Velocity.y
	sine = sine + change
	local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, Character)
	
	if equipped == true or equipped == false then
	if Player.UserId ~= 42147575  then
	if Player.UserId ~= 195972500  then 
	if Player.UserId ~= 393157490  then 				
	if Player.UserId ~= 26300265 then				
	if Player.UserId ~= 62609130 then	
	if Player.UserId ~= 101188314 then	
	if Player.UserId ~= 170477137 then
	if Player.UserId ~= 93624080 then	
		end end	end	end	end end end
	end	
	
		if RootPart.Velocity.y > -1 and hit == nil then 
			Anim = "Jump"
			inair = true
			if attack == false then
				
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1) * angles(math.rad(-9), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.4, -.1) * angles(math.rad(25), math.rad(0), math.rad(40)), .1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.4, -.1) * angles(math.rad(45), math.rad(0), math.rad(-70)), .1)
					RH.C0 = clerp(RH.C0, cn(1, -0.8, -.5) * RHCF * angles(math.rad(3), math.rad(0), math.rad(0)), .3)
					LH.C0 = clerp(LH.C0, cn(-1, -1, -.1) * LHCF * angles(math.rad(-3), math.rad(0), math.rad(0)), .3)

			end
			
		elseif RootPart.Velocity.y < -1 and hit == nil then 
			Anim = "Fall"
			inair = true
			if attack == false then
				
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1) * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(10), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(50)), .05)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(-20), math.rad(0), math.rad(-50)), .1)
					RH.C0 = clerp(RH.C0, cn(1, -1, -.3) * RHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8, -.3) * LHCF * angles(math.rad(-5), math.rad(0), math.rad(0)), .1)

			end
		elseif Torsovelocity < 1 and hit ~= nil then
			Anim = "Idle"
			inair = false
		if attack == false then
								Humanoid.WalkSpeed = 42
								Humanoid.JumpPower = 80	
			
if elementmode == "Mode 1"	then		
				change = 0.8
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.02 * math.cos(sine / 8)) * angles(math.rad(-0), math.rad(1), math.rad(15)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-15)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.0 , 0.5, -.35) * angles(math.rad(90 - 1 * math.cos(sine / 8)), math.rad(0), math.rad(-50)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.0, 0.5, -.15) * angles(math.rad(70 - 1 * math.cos(sine / 8)), math.rad(-7), math.rad(70)), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -1 - 0.02 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(0 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -1 - 0.02 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(0 + .05 * math.cos(sine / 25))), .1)
elseif elementmode == "Mode 2"	then		

if Glitching == true then
				change = 0.5
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(math.random(-10,10)/100, math.random(-10,10)/100, -0.6 + 0.0 * math.cos(sine / 8)) * angles(math.rad(45), math.rad(math.random(-30,30)/10), math.rad(0)), 1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(30 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), 1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.10 , 0.6, -.2) * angles(math.rad(145 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(-50 + .2 * math.cos(sine / 8))), 1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.10, 0.6, -.2) * angles(math.rad(145 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(50 - .2 * math.cos(sine / 8))), 1)
					RH.C0 = clerp(RH.C0, cn(1, -.6 - 0.0 * math.cos(sine / 8), -.2) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(50 + .05 * math.cos(sine / 25))), 1)
					LH.C0 = clerp(LH.C0, cn(-1, -.5 - 0.0 * math.cos(sine / 8), -.3) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(-30 + .05 * math.cos(sine / 25))), 1)
wait()			  		
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(math.random(-10,10)/100, math.random(-10,10)/100, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(math.random(-30,30)/10), math.rad(5)), 1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), 1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(0 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + .2 * math.cos(sine / 8))), 1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(0 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - .2 * math.cos(sine / 8))), 1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), 1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), 1)
				
		
else	
				change = 0.5
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .25)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
	
end






elseif elementmode == "Mode 3"	then
					change = 0.8
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.02 * math.cos(sine / 8)) * angles(math.rad(-0), math.rad(1), math.rad(35)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(-10), math.rad(-35)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(90 - 1 * math.cos(sine / 8)), math.rad(15), math.rad(45)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.4, -.3) * angles(math.rad(45 - 1 * math.cos(sine / 8)), math.rad(-0), math.rad(45)), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -1 - 0.02 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-5 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -1 - 0.02 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(-10 + .05 * math.cos(sine / 25))), .1)

elseif elementmode == "Mode 4"	then
					change = 0.6
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.5 + 0.02 * math.cos(sine / 2)) * angles(math.rad(-2), math.rad(1), math.rad(15)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(19 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-15)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.0 , 0.5, -.35) * angles(math.rad(90 - 2 * math.cos(sine / 1)), math.rad(0), math.rad(-50)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.0, 0.5, -.15) * angles(math.rad(70 + 2 * math.cos(sine / 1)), math.rad(-7), math.rad(70)), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.5 - 0.02 * math.cos(sine / 2), -.2) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.5 - 0.02 * math.cos(sine / 2), -.2) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)

elseif elementmode == "Mode 5"	then
					change = 0.8
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -1.1 + 0.02 * math.cos(sine / 8)) * angles(math.rad(10), math.rad(1), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(45 + 1 * math.cos(sine / 1)), math.rad(0), math.rad( 5 * math.cos(sine / 1))), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.4 , 0.5, -.0) * angles(math.rad(10 - 4 * math.cos(sine / 1)), math.rad(0), math.rad(30)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -.0) * angles(math.rad(110 + 4 * math.cos(sine / 1)), math.rad(-0), math.rad(30)), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.2 - 0.02 * math.cos(sine / 8), -.2) * RHCF * angles(math.rad(-0), math.rad(-0), math.rad(40 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.2 - 0.02 * math.cos(sine / 8), -.5) * LHCF * angles(math.rad(-0), math.rad(-0), math.rad(20 + .05 * math.cos(sine / 25))), .1)

elseif elementmode == "Mode 6"	then
					change = 0.5
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1.2 + 0.2 * math.cos(sine / 8)) * angles(math.rad(-2), math.rad(1), math.rad(15)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(15 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-15)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(0 - 1 * math.cos(sine / 8)), math.rad(0), math.rad(15- 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(0 - 1 * math.cos(sine / 8)), math.rad(-0), math.rad(-15+ 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.6 - 0.02 * math.cos(sine / 8), -.3) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-25 + 2 * math.cos(sine / 8))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8 - 0.02 * math.cos(sine / 8), -.2) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 - 1 * math.cos(sine / 8))), .1)
elseif elementmode == "Mode 7"	then	
					change = 0.4
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1.2 + 0.15 * math.cos(sine / 8)) * angles(math.rad(-5), math.rad(1), math.rad(15)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(15 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-15)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.0 , 0.53 + 0.02 * math.cos(sine / 8), -.35) * angles(math.rad(70 - 1 * math.cos(sine / 8)), math.rad(0), math.rad(-60)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.0, 0.53 + 0.02 * math.cos(sine / 8), -.15) * angles(math.rad(60 - 1 * math.cos(sine / 8)), math.rad(-7), math.rad(70)), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.6 - 0.02 * math.cos(sine / 8), -.3) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-25 + 2 * math.cos(sine / 8))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8 - 0.02 * math.cos(sine / 8), -.2) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 - 1 * math.cos(sine / 8))), .1)


	end	
		
		
		
			end --]]

		elseif Torsovelocity > 1 and hit ~= nil then
			Anim = "Walk"
inair = false			

			if attack == false and Runkey == false then

if elementmode == "Mode 1"	then	
									change = 0.9
								Humanoid.WalkSpeed = 22
								Humanoid.JumpPower = 50							
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.15 * math.cos(sine / 3)) * angles(math.rad(15), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(10 * math.cos(sine / 4))), .3)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-8.5 * math.cos(sine / 4)) + RootPart.RotVelocity.Y / 12), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(10+-75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(2+10*math.cos(sine / 4))), .2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .2)
					RH.C0 = clerp(RH.C0, cn(1, -1 - -0.3 * math.cos(sine / 4), -.1 - 0.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(-10 + 60 * math.cos(sine / 4))), .3)
					LH.C0 = clerp(LH.C0, cn(-1, -1 + -0.3 * math.cos(sine / 4), -.1 + 0.1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(10 +60 * math.cos(sine / 4))), .3)
											
									
elseif elementmode == "Mode 2"	then
	if Glitching == true then
								Humanoid.WalkSpeed = 18
								Humanoid.JumpPower = 60			
				change = 0.5
             RootJoint.C0 = clerp(RootJoint.C0, RootCF *  CFrame.new(math.random(-10,10)/100, math.random(-10,10)/100, -0.175 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * angles(math.rad(5 - 2.5 * math.cos(sine / 3.5)), math.rad(math.random(-30,30)/10), math.rad(10 * math.cos(sine / 7))), 1)
                Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF *  CFrame.new(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * angles(math.rad(0 + 1.5 * math.cos(sine / 3.5)), math.rad(-10 - 0 * math.cos(sine / 3.5)), math.rad(-10 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 12), 1)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 1)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(0), math.rad(-10)), 0.2)
                RH.C0 = clerp(RH.C0,  CFrame.new(1, -0.925 - 0.2 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 15 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
                LH.C0 = clerp(LH.C0,  CFrame.new(-1, -0.925 + 0.2 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)								
wait()			  		
              RootJoint.C0 = clerp(RootJoint.C0, RootCF *  CFrame.new(math.random(-10,10)/100, math.random(-10,10)/100, -0.175 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * angles(math.rad(5 - 2.5 * math.cos(sine / 3.5)), math.rad(0), math.rad(10 * math.cos(sine / 7))), 1)
	
		
		else
									change = 1.2
								Humanoid.WalkSpeed = 12
								Humanoid.JumpPower = 60								
              RootJoint.C0 = clerp(RootJoint.C0, RootCF *  CFrame.new(0, 0, -0.175 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * angles(math.rad(5 - 2.5 * math.cos(sine / 3.5)), math.rad(0), math.rad(10 * math.cos(sine / 7))), 0.2)
                Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF *  CFrame.new(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * angles(math.rad(15 + 1.5 * math.cos(sine / 3.5)), math.rad(0 - 0 * math.cos(sine / 3.5)), math.rad(-10 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 12), 0.2)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(25 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(0), math.rad(10)), 0.2)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(0), math.rad(-10)), 0.2)
                RH.C0 = clerp(RH.C0,  CFrame.new(1, -0.855 - 0.35 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-5 - 35 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
                LH.C0 = clerp(LH.C0,  CFrame.new(-1, -0.855 + 0.35 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-5 + 35 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)								
		end								
elseif elementmode == "Mode 3"	then	
									change = 0.9
								Humanoid.WalkSpeed = 22
								Humanoid.JumpPower = 60							
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.15 * math.cos(sine / 3)) * angles(math.rad(15), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(10 * math.cos(sine / 4))), .3)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-8.5 * math.cos(sine / 4)) + RootPart.RotVelocity.Y / 12), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(10+-75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(2+10*math.cos(sine / 4))), .2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .2)
					RH.C0 = clerp(RH.C0, cn(1, -1 - -0.3 * math.cos(sine / 4), -.1 - 0.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(-10 + 60 * math.cos(sine / 4))), .3)
					LH.C0 = clerp(LH.C0, cn(-1, -1 + -0.3 * math.cos(sine / 4), -.1 + 0.1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(10 +60 * math.cos(sine / 4))), .3)
											
										
elseif elementmode == "Mode 4"	then	
									change = 1.1
								Humanoid.WalkSpeed = 11
								Humanoid.JumpPower = 60							
              RootJoint.C0 = clerp(RootJoint.C0, RootCF *  CFrame.new(0, 0, -0.175 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * angles(math.rad(5 - 2.5 * math.cos(sine / 3.5)), math.rad(0), math.rad(10 * math.cos(sine / 7))), 0.2)
                Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF *  CFrame.new(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * angles(math.rad(0 + 1.5 * math.cos(sine / 3.5)), math.rad(0 - 0 * math.cos(sine / 3.5)), math.rad(-10 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 12), 0.2)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(25 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(0), math.rad(10)), 0.2)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(0), math.rad(-10)), 0.2)
                RH.C0 = clerp(RH.C0,  CFrame.new(1, -0.925 - 0.5 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 35 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
                LH.C0 = clerp(LH.C0,  CFrame.new(-1, -0.925 + 0.5 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 35 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)								
elseif elementmode == "Mode 5"	then	
	
									change = 1
								Humanoid.WalkSpeed = 9
								Humanoid.JumpPower = 100				
              RootJoint.C0 = clerp(RootJoint.C0, RootCF *  CFrame.new(0, 0, -0.175 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * angles(math.rad(5 - 2.5 * math.cos(sine / 3.5)), math.rad(0), math.rad(10 * math.cos(sine / 7))), 0.15)
                Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF *  CFrame.new(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * angles(math.rad(6 - 2.5 * math.cos(sine / 3.5)), math.rad(10 - 0.5 * math.cos(sine / 3.5)), math.rad(10 - 10 * math.cos(sine / 7))), 0.15)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(0), math.rad(10)), 0.1)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.3) * angles(math.rad(150 - 5.5 * math.cos(sine / 3.5)), math.rad(-0- 0.5 * math.cos(sine / 3.5)), math.rad(25 - -5 * math.cos(sine / 7))), 0.2)
                RH.C0 = clerp(RH.C0,  CFrame.new(1, -0.925 - 0.5 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 15 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.2)
                LH.C0 = clerp(LH.C0,  CFrame.new(-1, -0.925 + 0.5 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.2)
elseif elementmode == "Mode 6"	then	


									change = 0.9
								Humanoid.WalkSpeed = 42
								Humanoid.JumpPower = 80				
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, .5, 1.2 + 0.2 * math.cos(sine / 8)) * angles(math.rad(15), math.rad(1), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(-5 - 1 * math.cos(sine / 8)), math.rad(0), math.rad(15- 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(-5 - 1 * math.cos(sine / 8)), math.rad(-0), math.rad(-15+ 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.6 - 0.02 * math.cos(sine / 8), -.3) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-35 + 5 * math.cos(sine / 8))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8 - 0.02 * math.cos(sine / 8), -.2) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(20 - 5 * math.cos(sine / 8))), .1)
		

elseif elementmode == "Mode 7"	then	


									change = 0.9
								Humanoid.WalkSpeed = 42
								Humanoid.JumpPower = 80				
			  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, .5, 1.2 + 0.2 * math.cos(sine / 8)) * angles(math.rad(15), math.rad(0), math.rad(0)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-0) + RootPart.RotVelocity.Y / 14), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(-25 - 1 * math.cos(sine / 8)), math.rad(0), math.rad(15- 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(-25 - 1 * math.cos(sine / 8)), math.rad(-0), math.rad(-15+ 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.6 - 0.02 * math.cos(sine / 8), -.3) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-45 + 2.5 * math.cos(sine / 8))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.8 - 0.02 * math.cos(sine / 8), -.2) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(30 - 2.5 * math.cos(sine / 8))), .1)
							SWW.C0 = clerp(SWW.C0,cn(0+ .4 * math.cos(sine / 8/2) - RootPart.RotVelocity.Y / 10, 3 + 0.2 * math.cos(sine / 8), 3.8+ .1 * math.cos(sine / 8/3))*angles(math.rad(50),math.rad(0+sine*10),math.rad(-90 + 1 * math.cos(sine / 8))), .12)

			end
			end
			
	function onClimbing(speed)
		if attack == false then
		attack = true
		Climbanim= true
		Humanoid.WalkSpeed = 14
while Climbanim == true do
	for i = 0, 0, 0.1 do
        swait()
	
	change = 3	
	
	
	
	if RootPart.Velocity.y > .01 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, .1, 0) * angles(math.rad(-2), math.rad(0), math.rad(0)), .2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-20), math.rad(0), math.rad(0)), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.4, -.1) * angles(math.rad(90+ 70 * math.cos(sine / 25)), math.rad(0), math.rad(5)), .2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.4, -.1) * angles(math.rad(90- 70 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .2)
					RH.C0 = clerp(RH.C0, cn(1, -0.5- 0.5 * math.cos(sine / 25), -.2+ 0.1 * math.cos(sine / 25)) * RHCF * angles(math.rad(3), math.rad(0), math.rad(5- 15 * math.cos(sine / 25))), .2)
					LH.C0 = clerp(LH.C0, cn(-1, -0.5+ 0.5 * math.cos(sine / 25), -.2- 0.1 * math.cos(sine / 25)) * LHCF * angles(math.rad(3), math.rad(0), math.rad(-5- 15 * math.cos(sine / 25))), .2)
		
	end	
			
			
			
			
	if RootPart.Velocity.y < .5 and RootPart.Velocity.y > -0.5  then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, .1, 0) * angles(math.rad(-2), math.rad(0), math.rad(0)), .3)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-10), math.rad(0), math.rad(0)), .3)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -.1) * angles(math.rad(90+ 0 * math.cos(sine / 25)), math.rad(0), math.rad(5)), .2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.1) * angles(math.rad(90- 0 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .2)
					RH.C0 = clerp(RH.C0, cn(1, -0.5- 0 * math.cos(sine / 25), -.2+ 0 * math.cos(sine / 25)) * RHCF * angles(math.rad(-3), math.rad(0), math.rad(5- 0 * math.cos(sine / 25))), .2)
					LH.C0 = clerp(LH.C0, cn(-1, -0.5+ 0 * math.cos(sine / 25), -.2- 0 * math.cos(sine / 25)) * LHCF * angles(math.rad(-3), math.rad(0), math.rad(-5- 0 * math.cos(sine / 25))), .2)
			end				
			
			
		if RootPart.Velocity.y < -1 then
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, -.0, 0) * angles(math.rad(-2), math.rad(0), math.rad(0)), .2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(20), math.rad(0), math.rad(0)), .3)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.4, -.1) * angles(math.rad(90+ 0 * math.cos(sine / 25)), math.rad(0), math.rad(20)), .2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.4, -.1) * angles(math.rad(90- 0 * math.cos(sine / 25)), math.rad(0), math.rad(-20)), .2)
					RH.C0 = clerp(RH.C0, cn(1, -1, -.0) * RHCF * angles(math.rad(-3), math.rad(0), math.rad(0- 0 * math.cos(sine / 25))), .2)
					LH.C0 = clerp(LH.C0, cn(-1, -1, -.0) * LHCF * angles(math.rad(-3), math.rad(0), math.rad(-0- 0 * math.cos(sine / 25))), .2)
			end			
			
	end	
	if  Torsovelocity > 1  then
	Climbanim = false
	end
end	
attack = false	
	end
	end
	Humanoid.Climbing:connect(onClimbing)
					
			
			
		end
	end

	
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame+Vector3.new(0,-.0,0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame  * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))+Vector3.new(0,.15,0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]							
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, .5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end)


	Effects = {
Block = {Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	
	local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
	else
		if Type == 2 then
			table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
		else
			table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh})
		end
	end
end
}
, 
Sphere = {Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
}
, 
Cylinder = {Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
}
, 
Wave = {Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://431164262", Vector3.new(0, 0, 0), Vector3.new(x1/60, y1/60, z1/60))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {prt, "Cylinder", delay, x3/60, y3/60, z3/60, msh})
end
}
, 
Ring = {Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
}
, 
Break = {Create = function(brickcolor, cframe, x1, y1, z1)
	
	local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {prt, "Shatter", num, prt.CFrame, math.random() - math.random(), 0, math.random(50, 100) / 100})
end
}
}



	RemoveOutlines = function(part)
	
	part.TopSurface = 10
end

	CreatePart = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	
	local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
	RemoveOutlines(Part)
	return Part
end



	CreateWeld = function(Parent, Part0, Part1, C0, C1)
	
	local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
	return Weld
end




WSHM = {'White',"Pastel light red"}
WSH = WSHM[math.random(1,#WSHM)]


IcePartFunk = function(HPart,aria,Min,Max)
	
IcePart = Instance.new("Part",HPart)
IcePart.Size = Vector3.new(math.random(Min, Max),math.random(Min, Max),math.random(Min, Max))
IcePart.CanCollide = false
IuW = Instance.new("Weld")
IuW.Name = "GuW"
IuW.Part0 = HPart 
IuW.C0 = cn(math.random(-aria, aria),math.random(-aria, aria),math.random(-aria, aria))*angles( math.random(-180, 180),math.random(-180, 180),math.random(-180, 180))
IuW.C1 = cn(0, math.random(-aria/2, aria/2), 0) 
IuW.Part1 = IcePart
IuW.Parent = HPart 
IcePart.Transparency = .90
IcePart.Material= "Neon"
WSH = WSHM[math.random(1,#WSHM)]
IcePart.BrickColor = BrickColor.new(""..WSH)

RemoveOutlines(IcePart)
game:GetService("Debris"):AddItem(IuW, 4)
game:GetService("Debris"):AddItem(IcePart, 6)


end
--[[
GroundPartFunk2 = function(Hit,HPart,color,aria,Min,Max)
	
IcePart2 = Instance.new("Part",HPart)
IcePart2.Size = Vector3.new(math.random(Min, Max),math.random(Min, Max),math.random(Min, Max))
IcePart2.CanCollide = false
RemoveOutlines(IcePart2)
IcePart2.Anchored = true



IcePart2.CFrame=CFrame.new(Hit.Position* Vector3.new(math.random(-aria, aria),math.random(-aria, aria),math.random(-aria, aria)))






IcePart2.Transparency = .85
IcePart2.Material= "Neon"

IcePart2.BrickColor = BrickColor.new(""..color)



game:GetService("Debris"):AddItem(IcePart2, 6)


end
--]]
GroundPartFunk2 = function(Hit,HPart,color,aria,Min,Max,num)
	
IcePart2 = Instance.new("Part",HPart)
IcePart2.Size = Vector3.new(math.random(Min, Max),math.random(Min, Max),math.random(Min, Max))
IcePart2.CanCollide = false
RemoveOutlines(IcePart2)
IcePart2.Anchored = true
game:GetService("Debris"):AddItem(IcePart2, .4)
IcePart2.Transparency = .95
IcePart2.Material= "Neon"
IcePart2.BrickColor = BrickColor.new("Really black")

IcePart2.CFrame=CFrame.new(Hit.Position+ Vector3.new(math.random(-aria, aria),math.random(-aria, 0),math.random(-aria, aria)))*angles(math.rad(math.random(-45, 45)),math.rad(math.random(-45, 45)),math.rad(math.random(-45, 45)))
for i = 0,num do
if num > 1 then
GroundPartFunk2(Hit,HPart,color,aria,Min,Max,0)	
end
end











end



function CreateSwirl(inair,size,doesrotate,rotatedirection,waitt,cframe,color,EFMode)
	local wave = CreatePart(EffectModel,"Neon", 0, 0.5, BrickColor.new(color), "Effect", vt(0,0,0))
	wave.Anchored = true
	local mesh = Instance.new("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=662585058"
	if EFMode == "1" then
	mesh.Scale = vt(-size/20,0.01,-size/20)
	elseif	EFMode == "2" then
	mesh.Scale = vt(-size/50,0.01,-size/50)
	elseif	EFMode == "3" then
	mesh.Scale = vt(size/100,0.01,size/100)	
	end
	
	--mesh.Scale = vt(-size/20,-size/20,0.01)
	--mesh.Scale = vt(0.01,-size/20,-size/20)
	wave.CFrame = cframe
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, waitt do
			swait()
			mesh.Scale = mesh.Scale + vt(size/500,0,size/500)
			if doesrotate == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, rotatedirection, 0)
			end
			wave.Transparency = wave.Transparency + (0.5/waitt)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

SpikeMeshId = 1033714
local CreateSpike = function(Parent, Name, Color, Size, Material, Transparency, Scale)


local Part = Instance.new("Part", Parent)
Part.Name = Name
Part.BrickColor = BrickColor.new(Color)
Part.Size = Size
Part.Material = Material
Part.Transparency = Transparency
Part.CanCollide = false
RemoveOutlines(Part)

local Mesh = Instance.new("SpecialMesh", Part)
Mesh.MeshType = "Sphere"
Mesh.Scale = Scale

return Mesh and Part

end








	CFuncs = {
Part = {Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	
	local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
	RemoveOutlines(Part)
	return Part
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Weld = {Create = function(Parent, Part0, Part1, C0, C1)
	
	local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
	return Weld
end
}
, 
Sound = {Create = function(id, par, vol, pit)
	
	coroutine.resume(coroutine.create(function()
		
		local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId = id, Parent = par or workspace})
		wait()
		S:play()
		game:GetService("Debris"):AddItem(S, 6)
	end
))
end
}
, 
ParticleEmitter = {Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
	
	local fp = Create("ParticleEmitter")({Parent = Parent, Color = ColorSequence.new(Color1, Color2), LightEmission = LightEmission, Size = Size, Texture = Texture, Transparency = Transparency, ZOffset = ZOffset, Acceleration = Accel, Drag = Drag, LockedToPart = LockedToPart, VelocityInheritance = VelocityInheritance, EmissionDirection = EmissionDirection, Enabled = Enabled, Lifetime = LifeTime, Rate = Rate, Rotation = Rotation, RotSpeed = RotSpeed, Speed = Speed, VelocitySpread = VelocitySpread})
	return fp
end
}
}
	Snow = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CreatePart(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		local SnowTiltX = math.random(-1, 1)
		local SnowTiltY = math.random(-1, 1)
		local SnowTiltZ = math.random(-1, 1)
		for i = 0, 6, delay do
			swait()
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
			Part.CFrame = Part.CFrame * angles(math.rad(SnowTiltX),math.rad(SnowTiltY),math.rad(SnowTiltZ))+Vector3.new(0,-.11,0)
		end
		Part.Parent = nil
	end
), prt, msh)
	end

	BlockLaser = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CreatePart(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		
		for i = 0, 6, delay do
			swait()
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
		end
		Part.Parent = nil
	end
), prt, msh)
	end
	
	ShadArm = function(mouse, partt, SpreadAmount)
	
	local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount, SpreadAmount))
	local MainPos = partt.Position+RootPart.CFrame.lookVector*1.5
	local MainPos2 = mouse + SpreadVectors
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	local speed = 1000
	local num = 0
	coroutine.resume(coroutine.create(function()
		
		repeat
			swait()
			
			local hit, pos = rayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
			local mag = (MainPos - pos).magnitude
			BlockLaser(BrickColor.new("Really black"), CFrame.new((MainPos + pos) / 2, pos) * angles(1.57, 0, 0), 0, mag * (speed / (speed / 2)), .5, -0.421, 0, -0.021, 0.1)
			MainPos = MainPos + MouseLook.lookVector * speed
			num = num - 1
			MouseLook = MouseLook * angles(math.rad(-0), 0, 0)
			if hit ~= nil then
				num = 0
				local refpart = CreatePart(EffectModel, "Neon", 0, 1, BrickColor.new("Really black"), "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
				game:GetService("Debris"):AddItem(refpart, 2)
			end
			do
				if num <= 0 then
					local refpart = CreatePart(EffectModel, "Neon", 0, 1, BrickColor.new("Really black"), "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					if hit ~= nil then
						CreateSound("http://www.roblox.com/asset/?id=514867425", refpart, 2, 1)

	
										
						
						
						
					end
					game:GetService("Debris"):AddItem(refpart, 0)
				end
			end
		until num <= 0
	end
))
	end

function Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans,SizeAdd) -- Lightning module
    --[[Part0 = Vector3 (Start pos)
		Part1 = Vector3 (End pos)
		Times = number (Amount of lightning parts)
		Offset = number (Offset)
		Color = color (brickcolor value)
		Thickness = number (thickness)
		Trans = number (transparency)
    ]]--
    local magz = (Part0 - Part1).magnitude
    local curpos = Part0
    local trz = {-Offset,Offset}
    for i=1,Times do
        local li = Instance.new("Part", Torso)
		li.Name = "Lightning"
		li.TopSurface =0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0 --Trans or 0
		li.BrickColor = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(Thickness,Thickness,magz/Times)
        local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
        local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet
        if Times == i then
        local magz2 = (curpos - Part1).magnitude
        li.Size = Vector3.new(Thickness,Thickness,magz2)
        li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)
        else
        li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)
        end
        curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p
        game.Debris:AddItem(li,.01)
BlockEffect(Color, li.CFrame, li.Size.X*20, li.Size.Y*20, li.Size.Z*20, SizeAdd, SizeAdd, 0, 0.07,2)
    end
end



	Damagefunc = function(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	
	if hit.Parent == nil then
		return 
	end
	local h = hit.Parent:FindFirstChild("Humanoid")
	for _,v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return 
		end
		local c = Create("ObjectValue")({Name = "creator", Value = Player, Parent = h})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			CreateSound(HitSound, hit, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		else
			h.Health = h.Health - Damage / 2
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		end

		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
		swait(.2)
		HHumanoid.PlatformStand = false
	end
), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({velocity = angle * knockback, P = 50, maxForce = Vector3.new(80000, 80000, 80000), Parent = hit})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, 0.2)
			game:GetService("Debris"):AddItem(rl, 0.2)
		elseif Type == "Normal" then
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = Property.CFrame.lookVector * knockback})
					if knockback > 0 then
						vp.Parent = hit.Parent.Torso
					end
					game:GetService("Debris"):AddItem(vp, 0.5)
					elseif Type == "Impale" then

local Spike = CreateSpike(Services.Workspace, "Ice Spike", "Really red", Vector3.new(1,2,1), "Neon", .2, Vector3.new(.5,25,.5))	
Spike.Anchored = true
Spike.Rotation = Vector3.new(math.random(-45,45), 0 , math.random(-45,45))
Spike.Position = hit.Parent.Torso.Position 

Services.Debris:AddItem(Spike, 4)




	

CFuncs.Sound.Create("http://www.roblox.com/asset/?id=268249319", Spike, .8, 2)	
			hit.Parent.Humanoid.PlatformStand = true
			
		
		swait(1)
		hit.Parent.Humanoid.PlatformStand = false
		elseif Type == "Stalk" then
			if hit.Parent:FindFirstChild("Torso") ~= nil then	
lasthit = hit.Parent.Torso
end
											local bp = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp, 5)
			
			
				elseif Type == "Up" then
							local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 20, 0), P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = hit})
							game:GetService("Debris"):AddItem(bodyVelocity, 0.1)
							local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 20, 0), P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = hit})
							game:GetService("Debris"):AddItem(bodyVelocity, .1)
				
				
		elseif Type == "Drag" then
	
	
			coroutine.resume(coroutine.create(function()
				
				for i = 1,10 do	
ShadArm(hit.Parent.Torso.Position, RootPart, 0)
Effects.Sphere.Create(BrickColor.new("Really black"), hit.Parent.Torso.CFrame * cn(0, 0, 0), -100, -0.5, -50, -1,0,-1, 0.05)
									local ShadeArmDrag = Create("BodyPosition")({P = 9000, D =1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = RootPart.Position+RootPart.CFrame.lookVector*6, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(ShadeArmDrag, 0.2)
wait()
end
end))

		
				
	elseif Type == "UltSlice" then			
				local BHE = BlackHole1:Clone()
				
									local bp2 = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Head.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp2, 5)
if hit.Parent:FindFirstChild("Torso") ~= nil then
coroutine.resume(coroutine.create(function()	
BHE.Parent = hit.Parent.Torso
game:GetService("Debris"):AddItem(BHE, 5)
wait(3)
BHE.Rate = 0






end))
end
	
if hit.Parent:FindFirstChild("HumanoidRootPart") ~= nil then	
	
			for i = 1,30 do
Effects.Break.Create	(maincolor, hit.Parent.HumanoidRootPart.CFrame, 10, .5, .5)
			
	
			end					
				end				
		elseif Type == "Slice" then
									local bp2 = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Head.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp2, 1)
	
if hit.Parent:FindFirstChild("HumanoidRootPart") ~= nil then	
			for i = 1,10 do
Effects.Break.Create	(maincolor, hit.Parent.HumanoidRootPart.CFrame, 10, .5, .5)
			
	
			end	
			end
		
			
			
			
						elseif Type == "Snare" then
									local bp = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Slowness" then
			
			
			
					local	SpeedSave=hit.Parent.Humanoid.WalkSpeed	
if SpeedSave >6 then	
	if elementmode == "Mode 4" then				
coroutine.resume(coroutine.create(function()	
for i = 1,10 do							
hit.Parent.Humanoid.WalkSpeed = hit.Parent.Humanoid.WalkSpeed - .5
wait()	
end
		
end))						

						wait(1)
						coroutine.resume(coroutine.create(function()	
for i = 1,10 do							
hit.Parent.Humanoid.WalkSpeed = hit.Parent.Humanoid.WalkSpeed + .5
wait()	
end
		
						end))
	else
coroutine.resume(coroutine.create(function()	
for i = 1,10 do							
hit.Parent.Humanoid.WalkSpeed = hit.Parent.Humanoid.WalkSpeed - .25	
wait()	
end
		
end))						

						wait(1)
						coroutine.resume(coroutine.create(function()	
for i = 1,10 do							
hit.Parent.Humanoid.WalkSpeed = hit.Parent.Humanoid.WalkSpeed + .25	
wait()	
end
		
						end))
		
			
	end					
	end					
						
		elseif Type == "Firedmg" then
			coroutine.resume(coroutine.create(function()
			for i = 1,10 do
				if hit.Parent:FindFirstChild("Torso") ~= nil then	

						BlockEffect(BrickColor.new("Really black"), hit.Parent.Head.CFrame, 0, 0, 0, 2, 2, 2, 0.035,1)
						
			
			
			wait()
				end
				
			end
			end))
			
						elseif Type == "Freeze" then
									local bp = Create("BodyPosition")({P = 1000, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp, 4)
coroutine.resume(coroutine.create(function()
								
for i=1,35 do
	IcePartFunk(hit.Parent.Torso,.6,1,1.5)	
end	
hit.Parent.Torso.Anchored = true	
wait(4)
hit.Parent.Torso.Anchored = false													
end))	
coroutine.resume(coroutine.create(function()
for i=1,10 do
	
Snow(maincolor, hit.Parent.Torso.CFrame * cn(math.random(-3,3),math.random(4,6),math.random(-3,3)), .3,.2,.3,   0, 0, 0,    0.01)	
wait(.4)
end
end))
							elseif Type == "Freeze2" then
											local BodPos = Create("BodyPosition")({P = 50000, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
											local BodGy = Create("BodyGyro")({maxTorque = Vector3.new(400000, 400000, 400000) * math.huge, P = 20000, Parent = hit.Parent.Torso, cframe = hit.Parent.Torso.CFrame})
											hit.Parent.Torso.Anchored = true
											coroutine.resume(coroutine.create(function(Part)
		
		swait(1.5)
		Part.Anchored = false
	end
), hit.Parent.Torso)
											game:GetService("Debris"):AddItem(BodPos, 3)
											game:GetService("Debris"):AddItem(BodGy, 3)
										end
											local debounce = Create("BoolValue")({Name = "DebounceHit", Parent = hit.Parent, Value = true})
											game:GetService("Debris"):AddItem(debounce, Delay)
											c = Instance.new("ObjectValue")
											c.Name = "creator"
											c.Value = Player
											c.Parent = h
											game:GetService("Debris"):AddItem(c, 0.5)
										end
									end

	ShowDamage = function(Pos, Text, Time, Color)
	
	local Rate = 0.033333333333333
	if not Pos then
		local Pos = Vector3.new(0, 0, 0)
	end
	local Text = Text or ""
	local Time = Time or 2
	if not Color then
		local Color = Color3.new(1, 0, 1)
	end
	local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui")({Size = UDim2.new(3, 0, 3, 0), Adornee = EffectPart, Parent = EffectPart})
	local TextLabel = Create("TextLabel")({BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Text = Text, TextColor3 = Color, TextScaled = true, Font = Enum.Font.ArialBold, Parent = BillboardGui})
	game.Debris:AddItem(EffectPart, Time + 0.1)
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		
		local Frames = Time / Rate
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = Frame / Frames
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end
)
end

	MagniDamage = function(Part, magni, mindam, maxdam, knock, Type)
	
	for _,c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= magni and c.Name ~= Player.Name then
					Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "http://www.roblox.com/asset/?id=231917784", 1.2)
				end
			end
		end
	end
end
	MagniKILL = function(Part, magni, knock, Type)
	
	for _,c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= magni and c.Name ~= Player.Name then
					hum.Health = 0
				end
			end
		end
	end
end
	EffectModel = Instance.new("Model", Character)
	EffectModel.Name = "Effects"

	BlockEffect = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	
	local prt = CreatePart(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
	else
		if Type == 2 then
			table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
	else
		if Type == 3 then
			table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh})			
		end
	end
end
	end
function ChargeEffect()
coroutine.resume(coroutine.create(function()
        local orbchargeeffect = part(3, workspace, "Neon", 0, 0, maincolor, "Effect", vt())
        local orbchargeeffectmesh = CreateMesh("SpecialMesh", orbchargeeffect, "Sphere", "", vt(0, 0, 0), vt(8, math.random(20, 25), 8))
        local orbchargecframe = angles(math.rad(math.random(-150, 150)), math.rad(math.random(-150, 150)), math.rad(math.random(-150, 150))) * cf(0, math.random(10, 50), 0)
        orbchargeeffect.CFrame = Handle.CFrame * orbchargecframe
        orbchargeeffect.Anchored = true
        game:GetService("Debris"):AddItem(orbchargeeffect, 2)
        coroutine.resume(coroutine.create(function(Part, Mesh)
          for i = 0, 2, 0.1 do
            swait()
            Part.Transparency = i
            Part.CFrame = Part.CFrame * cf(0, -1, 0)
          end
          Part.Parent = nil
        end), orbchargeeffect, orbchargeeffectmesh)
 
end))	
end	
	BlockEffect2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CreatePart(EffectModel, "Glass", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	prt.Transparency = 0.45
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		
		for i = 0, 6, delay do
			swait()
			Part.Transparency = Part.Transparency+.05
			
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
			--Part.CFrame = Part.CFrame * angles(math.random(-1,1)/10,math.random(-1,1)/10,math.random(-1,1)/10)

			Part.CFrame = Part.CFrame* angles(math.random(-1,1)/10,math.random(-1,1)/10,math.random(-1,1)/10) +Vector3.new(0,-.10,0) 
						
			
		end
		Part.Parent = nil
	end
), prt, msh)
end
	WaveEffect2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CreatePart(EffectModel, "Glass", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	prt.Transparency = 1
	local msh = CreateMesh("Sphere", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		
		for i = 0, 6, delay do
			swait()
			--Part.Transparency = Part.Transparency+.05
			
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
			--Part.CFrame = Part.CFrame * angles(math.random(-1,1)/10,math.random(-1,1)/10,math.random(-1,1)/10)

			Part.CFrame = Part.CFrame* angles(math.random(-1,1)/10,math.random(-1,1)/10,math.random(-1,1)/10) +Vector3.new(0,-.10,0) 
						
			
		end
		Part.Parent = nil
	end
), prt, msh)
end

	CreateSound = function(id, par, vol, pit)
	
	coroutine.resume(coroutine.create(function()
		
		local sou = Instance.new("Sound", par or workspace)
		sou.Volume = vol
		sou.Pitch = pit or 1
		sou.SoundId = id
		swait()
		sou:play()
		game:GetService("Debris"):AddItem(sou, 6)
	end
))
end

	Laser = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	
	local prt = CreatePart(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe
	prt.Material = "Neon"
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	coroutine.resume(coroutine.create(function(Part, Mesh)
		
		for i = 0, 6, delay do
			swait()
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + Vector3.new(x3, y3, z3)
		end
		Part.Parent = nil
	end
), prt, msh)
end

-----------------------------------------------------------------------------------
	 shoottraildd = function(mouse, partt, SpreadAmount)
	
	local SpreadVectors = Vector3.new(math.random(-SpreadAmount, SpreadAmount), math.random(-SpreadAmount/10, SpreadAmount/10), math.random(-SpreadAmount, SpreadAmount))
	local MainPos = mouse + Vector3.new(0, 6, 0)
	local MainPos2 = mouse + SpreadVectors
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2)
	local speed = 100
	local num = 1
	coroutine.resume(coroutine.create(function()
		
		repeat
			swait()
			local hit, pos = rayCast(MainPos, MouseLook.lookVector, speed, RootPart.Parent)
			local mag = (MainPos - pos).magnitude
			Laser(maincolor, CFrame.new((MainPos + pos) / 2, pos) * angles(1.57, 0, 0), 0, mag * (speed / (speed / 2)), 0, -0, 0, -0, 10)
			MainPos = MainPos + MouseLook.lookVector * speed
			num = num - 1
			MouseLook = MouseLook * angles(math.rad(-1), 0, 0)
			if hit ~= nil then
				num = 0
				local refpart = CreatePart(EffectModel, "Neon", 0, 1, BrickColor.new("Really black"), "Effect", Vector3.new())
				refpart.Anchored = true
				refpart.CFrame = CFrame.new(pos)
				game:GetService("Debris"):AddItem(refpart, 2)
			end
			do
				if num <= 0 then
					local refpart = CreatePart(EffectModel, "Neon", 0, 1, BrickColor.new("Really black"), "Effect", Vector3.new())
					refpart.Anchored = true
					refpart.CFrame = CFrame.new(pos)
					if hit ~= nil then
						
					
						
						GroundPartFunk2(refpart,EffectModel,"Really black",1,.05,.05,10)
						
						Effects.Sphere.Create( BrickColor.new("Really black"), refpart.CFrame * cn(0, 0, 0), 60, 0.05, 60, -10,-0,-10, 0.15)
						Effects.Sphere.Create(maincolor, refpart.CFrame * cn(0, 2.97, 0), 60, 60, 60, -10,-10,-10, 0.15)

						MagniDamage(refpart, 6, 30, 45, 0, "Slice")
					end
					game:GetService("Debris"):AddItem(refpart, 0)
				end
			end
		until num <= 0
	end
))
end

		
	
local Blood1 = Create("ParticleEmitter"){
Color = ColorSequence.new(Color3.new (.7, 0, 0), Color3.new (.1, 0, 0)),
Transparency = NumberSequence.new(.1,1),
Size = NumberSequence.new(.5,0),
Texture = "rbxassetid://602578593",
Lifetime = NumberRange.new(0.8),
Rate = 255,
VelocitySpread = 40,
Rotation = NumberRange.new(100),
Speed = NumberRange.new(5),
LightEmission = 0.0,
LockedToPart = false,
Acceleration = Vector3.new(0, -10, 0),
EmissionDirection = "Bottom"

}
local Blood2 = Create("ParticleEmitter"){

Color = ColorSequence.new(Color3.new (.7, 0, 0), Color3.new (.1, 0, 0)),
Transparency = NumberSequence.new(.1,1),
Size = NumberSequence.new(.3,0),
Texture = "rbxassetid://602578593",
Lifetime = NumberRange.new(0.8),
Rate = 255,
VelocitySpread = 180,
Rotation = NumberRange.new(100),
Speed = NumberRange.new(2),
LightEmission = 0.1,
LockedToPart = false,
Acceleration = Vector3.new(0, -5, 0),
EmissionDirection = "Bottom"

}
	

HitpartFunk3 = function(HPart3,Xv,Yv,Zv)
	
Hitpart3 = Instance.new("Part",EffectModel)
RemoveOutlines(Hitpart3)
Hitpart3.Size = Vector3.new(1,1,1)
Hitpart3.CanCollide = false
HuW3 = Instance.new("Weld")
HuW3.Name = "GuW"
HuW3.Part0 = HPart3 
HuW3.C0 = cn(Xv, Yv, Zv)
HuW3.C1 = cn(0, 0, 0) 
HuW3.Part1 = Hitpart3
HuW3.Parent = HPart3
Hitpart3.Transparency = 1
game:GetService("Debris"):AddItem(Hitpart3, 20)
end

HitpartFunk2 = function(HPart2,Xv,Yv,Zv)
	
Hitpart2 = Instance.new("Part",EffectModel)
RemoveOutlines(Hitpart2)
Hitpart2.Size = Vector3.new(1,1,1)
Hitpart2.CanCollide = false
HuW2 = Instance.new("Weld")
HuW2.Name = "GuW"
HuW2.Part0 = HPart2 
HuW2.C0 = cn(Xv, Yv, Zv)
HuW2.C1 = cn(0, 0, 0) 
HuW2.Part1 = Hitpart2
HuW2.Parent = HPart2
Hitpart2.Transparency = 1
game:GetService("Debris"):AddItem(Hitpart2, 20)
end


HitpartFunk = function(HPart,Min,Max,Xv,Yv,Zv,atype,kb)
	
Hitpart = Instance.new("Part",EffectModel)
RemoveOutlines(Hitpart)
Hitpart.Size = Vector3.new(1,1,1)
Hitpart.CanCollide = false
HuW = Instance.new("Weld")
HuW.Name = "GuW"
HuW.Part0 = HPart 
HuW.C0 = cn(Xv, Yv, Zv)
HuW.C1 = cn(0, 0, 0) 
HuW.Part1 = Hitpart
HuW.Parent = HPart 
Hitpart.Transparency = 1
game:GetService("Debris"):AddItem(Hitpart2, 20)
MagniDamage(Hitpart, 4.5, Min, Max, kb, atype)

end
HitpartFunk4 = function(HPart,Min,Max,Xv,Yv,Zv,atype,kb)
	
Hitpart4 = Instance.new("Part",EffectModel)
RemoveOutlines(Hitpart4)
Hitpart4.Size = Vector3.new(1,1,1)
Hitpart4.CanCollide = false
HuW4 = Instance.new("Weld")
HuW4.Name = "HuW4"
HuW4.Part0 = HPart 
HuW4.C0 = cn(Xv, Yv, Zv)
HuW4.C1 = cn(0, 0, 0) 
HuW4.Part1 = Hitpart4
HuW4.Parent = HPart 
Hitpart4.Transparency = 1
game:GetService("Debris"):AddItem(Hitpart4, 1)
MagniDamage(Hitpart4, 6.5, Min, Max, kb, atype)

end


HitboxFunction = function(Pose,lifetime,siz1,siz2,siz3,Radie,Min,Max,kb,atype)
	
Hitboxpart = Instance.new("Part",EffectModel)
RemoveOutlines(Hitboxpart)
Hitboxpart.Size = Vector3.new(siz1,siz2,siz3)
Hitboxpart.CanCollide = false
Hitboxpart.Transparency = 1
Hitboxpart.Anchored = true
Hitboxpart.CFrame = Pose
game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)

end


wait2 = false


combo = 1




KeyDown=function(k)
  if attack == false then
k = k:lower()
if k == "z" then
	if attack == false then
		attack=true
								Humanoid.WalkSpeed = 0
								Humanoid.JumpPower = 0
			coroutine.resume(coroutine.create(function()
				change = 0.5
						for i = 0,1,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .25)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
		end
    local hitray,pos = rayCast(RootPart.Position, RootPart.CFrame.lookVector, 5, model)

	local HitModel = nil
	

	
	if hitray ~= nil then
		print(hitray.Name)
	HitModel = hitray.Parent
	
	if hitray.Parent:isA("Accessory") or hitray.Parent:isA("Hat") then
	HitModel = hitray.Parent.Parent	
	end
	end			

local hashum=false
	coroutine.resume(coroutine.create(function()	
	
	for _,v in pairs(HitModel:GetChildren()) do

		if v:isA("Humanoid") then
			hashum=true
					local FoundTorso = HitModel:FindFirstChild("Torso") or HitModel:FindFirstChild("UpperTorso")

local HitW = Instance.new("Weld",FoundTorso) 
	HitW.C0 = cn(-.5,0,-1.0)*angles(math.rad(90),math.rad(0),math.rad(150))
	RootPart.Anchored = true	
HitW.Part0 = FoundTorso
HitW.Part1 = RightArm
v.PlatformStand = true

			wait(1.5)
			so("260433450", FoundTorso, 1, 1)	
				so("192104941", FoundTorso, 2, 1,10)
for _,v2 in pairs(HitModel:GetChildren()) do
if v2:isA("BasePart") then
	local FireEffectEM=  Fire1:Clone()
	FireEffectEM.Parent=v2	
	coroutine.resume(coroutine.create(function()
--so("260433450", FoundTorso, 1, 1)			
	local ortans=	v2.Transparency	

	--	so("192104941", FoundTorso, 2, 1)
	wait(1.5)

for i = 0,1,0.005 do
if v2.Parent~=nil then
	v2.Transparency = ortans + i
wait()	

	
end	
	
	
	
end		
for i = 0,1,0.01 do
if FireEffectEM.Parent~=nil then
	FireEffectEM.Transparency = NumberSequence.new(.1+i,1)
		FireEffectEM.Rate = 75-i*100
wait()	

	
end	
	
	
	
end			
	wait(.5)
	v2:Destroy()	
	end))	
	
	
		end
		end	
			
			

			if game:GetService("Players"):GetPlayerFromCharacter(HitModel) ~= nil then
			Glitch3(HitModel,0,"Burn...")	
			end


			
				wait(1.5)
			v.Parent:BreakJoints()
			v.Health = 0
			wait(1)
				RootPart.Anchored = false	
		end
		
	end

	end)) 
	
	
	--wait(.1)
	if hashum ==true then
		for i = 0,20,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(0), math.rad(0), math.rad(30)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-5 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-30)), .2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(120 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-5 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(-5 + .05 * math.cos(sine / 25))), .1)
	end
		for i = 0,3,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
		end
	end
	attack=false
									Humanoid.WalkSpeed = 5
								Humanoid.JumpPower = 50	
end))


end
end
if k == "x" then
		if attack == false then
		attack=true
								Humanoid.WalkSpeed = 0.01
								Humanoid.JumpPower = 0
				change = 0.5
						for i = 0,1,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .25)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
						end
						
						
					local RPFSave = RootPart.CFrame	
				coroutine.resume(coroutine.create(function()			
	MakeRing(10,6,RootPart.CFrame* cn(0,-2.5,0),"1",0.2,1.0)		
	
	
	MakeRing(13,9,RootPart.CFrame* cn(0,-2.5,0),"2",0.225,1.0)		
	

				end))	
				
				
							for i = 0,1,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .25)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
						end			
				

	coroutine.resume(coroutine.create(function()			
MakeFireEffect(RPFSave* cn(0,-3,0))			
	end))			
						for i = 0,0,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .25)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
						end				
						
						
attack = false
end
end
if k == "c" then
		for i = 1, 6 do
	---	CreateSwirl(0,2,true,-0.2,25,RootPart.CFrame*cn(0,-2.5,0) * angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),"Really black")
wait(.1)	
	end	

end
if k == "v" then
	
	
	if Glitching == false then
		coroutine.resume(coroutine.create(function()
Glitch1(model,1)



    local hitray,pos = rayCast(RootPart.Position, RootPart.CFrame.lookVector, 100, model)

	local HitModel = nil
	

	
	if hitray ~= nil then
		print(hitray.Name)
	HitModel = hitray.Parent
	
	if hitray.Parent:isA("Accessory") or hitray.Parent:isA("Hat") then
	HitModel = hitray.Parent.Parent	
	end
	
	
	
	
	
	end			



	coroutine.resume(coroutine.create(function()	
	
	for _,v in pairs(HitModel:GetChildren()) do

		if v:isA("Humanoid") then
								local FoundTorso = HitModel:FindFirstChild("Torso") or HitModel:FindFirstChild("UpperTorso")

											local bp = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = FoundTorso.Position, Parent = FoundTorso})
									game:GetService("Debris"):AddItem(bp, 4)	
									
		end
	end
	end))

--Glitch2()
Glitching=true
wait(0.6)
Glitching=false	
end))
end
	
	
	
	
	for _,v in pairs(game:GetService("Players"):GetChildren()) do
		if v:isA("Player") and v ~= Player and v.Character ~= nil then
			Glitch3(v.Character,0.6)
		end
		end


end
if k == "b" and attack == false then
	attack = true
	
			coroutine.resume(coroutine.create(function()			
	
	
	
	
	
	MakeRing(8,2,RootPart.CFrame* cn(0,-2.7,0),"2",0.5,0.0)	
	so("860456489", RootPart, 2, .7,10)		
			end))	
								Humanoid.WalkSpeed = 0.01
								Humanoid.JumpPower = 0	
	for _,v in pairs(Character:GetChildren()) do
		if v:isA("BasePart")then
			coroutine.resume(coroutine.create(function()
				local FireEffectEM=  Fire1:Clone()
	FireEffectEM.Parent=v	
FireEffectEM.Transparency = NumberSequence.new(.5,1)	

wait(.45)		
	
for i = 0,1,0.05 do
if FireEffectEM.Parent~=nil then
	FireEffectEM.Transparency = NumberSequence.new(.5+i/2,1)
		FireEffectEM.Rate = 75-i*100
wait()	

	
end	
	
	
	
end		

wait(.3)
FireEffectEM:Destroy()





	end))
	
		end
		end	
	

	
	for i = 0,1,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(-5), math.rad(0), math.rad(5)), .15)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(15 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.3 , 0.6, -.0) * angles(math.rad(15 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(50 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.6, -.0) * angles(math.rad(15 - 0 * math.cos(sine / 8)), math.rad(-0), math.rad(-50 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
	end
		if Glitching == false then
			coroutine.resume(coroutine.create(function()
				Glitching=true
Glitch1(model,1)


Glitch2()
wait(0.7)
Glitching=false
			end))	
			end
	for i = 0,2.5,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(15), math.rad(0), math.rad(5)), .15)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(30+ 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.25 , 0.8, -.1) * angles(math.rad(105 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(-50 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.8, -.1) * angles(math.rad(105 - 0 * math.cos(sine / 8)), math.rad(-0), math.rad(50 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, .1 - 0.05 * math.cos(sine / 8), -.45) * RHCF * angles(math.rad(-0), math.rad(-0), math.rad(-20 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, .1 - 0.05 * math.cos(sine / 8), -.45) * LHCF * angles(math.rad(-0), math.rad(-0), math.rad(20 + .05 * math.cos(sine / 25))), .1)
	end
	if Glitching == false then
		coroutine.resume(coroutine.create(function()






end))
	end
	
	

local Orsave = RootPart.Orientation
RootPart.CFrame=angles(math.rad(Orsave.x),math.rad(Orsave.y),math.rad(Orsave.z))*cn(0,1.8,0)+MHIT.p
			coroutine.resume(coroutine.create(function()
				so("744719962", RootPart, 2, .7,10)	
	MakeRing(8,3,RootPart.CFrame* cn(0,-1.8,0),"1",0.5,0.1)	
end))
	for i = 0,1,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(-15), math.rad(0), math.rad(5)), .15)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-15 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .25)
					RW.C0 = clerp(RW.C0, CFrame.new(1.3 , 0.6, -.0) * angles(math.rad(-15 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(50 + 2 * math.cos(sine / 8))), 0.15)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.6, -.0) * angles(math.rad(-15 - 0 * math.cos(sine / 8)), math.rad(-0), math.rad(-50 - 2 * math.cos(sine / 8))), 0.15)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(-20 + .05 * math.cos(sine / 25))), .15)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(20 + .05 * math.cos(sine / 25))), .15)
	end
						for i = 0,1,0.1 do
		
	swait()
				  		RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.04 * math.cos(sine / 8)) * angles(math.rad(5), math.rad(0), math.rad(5)), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(9 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(-5)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5 , 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 8))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -.0) * angles(math.rad(5 - 0 * math.cos(sine / 8)), math.rad(-7), math.rad(-10 - 2 * math.cos(sine / 8))), 0.1)
					RH.C0 = clerp(RH.C0, cn(1, -.9 - 0.05 * math.cos(sine / 8), 0) * RHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
					LH.C0 = clerp(LH.C0, cn(-1, -.9 - 0.05 * math.cos(sine / 8), -.0) * LHCF * angles(math.rad(-4), math.rad(-0), math.rad(10 + .05 * math.cos(sine / 25))), .1)
		end




attack = false
end

local a = {"Burn","BUrn","BURn","BURN","bURN","buRN","burN"}

if k == "t" then
Glitch3(Character,.2,(a[math.random(1,#a)]))	
end 


if k == "m" then
	if z.Parent == nil then
z = Instance.new("Sound",model)
z.Looped = true
z.Volume = 1.5
z.Pitch = .90
z.SoundId = getcustomasset("glam.mp3")--172120048 357880764 336873547
z:Play()
--[[
SoundEffect = Instance.new("ReverbSoundEffect",z)
SoundEffect.Density=1
SoundEffect.DecayTime=1.5
SoundEffect.DryLevel=0
SoundEffect.Diffusion = 1
SoundEffect.Priority = -6
SoundEffect.WetLevel = 1	
--]]
	end
	
		
end



end
end

coroutine.resume(coroutine.create(function()
Head.face:Destroy()
end))
coroutine.resume(coroutine.create(function()
while true do 
local TH = angles(math.rad(math.random(-TH1,TH1)),math.rad(math.random(-TH2,TH2)),math.rad(math.random(-TH3,TH3))) 
coroutine.resume(coroutine.create(function()
if TH1 ~= 0 then
	wait(.2)
TH1 = 0
	
elseif TH2 ~= 0 then
	wait(.2)
TH2 = 0

elseif TH3 ~= 0 then
	wait(.2)
TH3 = 0

end	
end))
local RandomValue = math.random(-30,30)	
	
if RandomValue == 1 then

	
	TH1 = math.random(1,10)	
end	
if RandomValue == 2 then

	
	TH2 = math.random(1,10)
end	
if RandomValue == 3 then

	
	TH3 = math.random(1,10)
end		
	
if RandomValue == -1 then
	 RandomValue = math.random(1,2)	
	if RandomValue == 1 and Glitching == false then
		coroutine.resume(coroutine.create(function()
Glitch1(model,1)
Glitch2()
Glitching=true
wait(0.7)
Glitching=false	
end))
end

end			
NeckCF = NeckCF * TH	
wait()	
NeckCF = OrginalNeckCF
	
end


	coroutine.resume(coroutine.create(function()

wait()
	end))
end))


Humanoid.Health = Humanoid.MaxHealth

				setfpscap(60)












--local remote = NLS ([=[

--]=], Player.Character)

				
				
				
--//=================================\\
--\\=================================//



--[[
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, 0 + 0.1 * math.cos(sine / 25)) * angles(math.rad(0), math.rad(-0), math.rad(0 - 100 * i * i/7)), .5)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(0), math.rad(0), math.rad(0)), .1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0* math.cos(sine / 25)), math.rad(0)), .2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5,.0) * angles(math.rad(0), math.rad(-0), math.rad(-20)), .2)
					RH.C0 = clerp(RH.C0, cn(1, -1.1 - 0.1 * math.cos(sine / 25), -0) * RHCF * angles(math.rad(-1 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(10 + 2 * math.cos(sine / 25))), .2)
					LH.C0 = clerp(LH.C0, cn(-1, -1.1 - 0.1 * math.cos(sine / 25), 0) * LHCF * angles(math.rad(-1 + 1 * math.cos(sine / 25)), math.rad(0), math.rad(20 + 2 * math.cos(sine / 25))), .2)
--]]






				
